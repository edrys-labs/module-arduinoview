{"mappings":"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","sources":["<anon>","src/index.ts"],"sourcesContent":["const communication = navigator;\nvar port = null;\nvar writer = null;\nvar reader = null;\nvar sandbox = document.getElementById(\"sandbox\")?.contentWindow;\n// an object containing objects that can be distinguished from each other (is used like an enumeration in onReceiveCallback\nvar frmstatus = {\n    no: {},\n    in: {},\n    esc: {}\n};\nvar receiverstatus = frmstatus.no;\nvar stringReceived = \"\";\n// teletype framing with escaping\nconst SOF = 0x01;\nconst EOF = 0x04;\nconst ESC = 0x10;\nconst ESCMASK = 0x40;\n//logger is used to debug the sending and receiving of messages logging contains the log,level, which determines how many messages are logged to the debug console\nvar logging = 0;\nconst buttonConnect = document.getElementById(\"connect\");\nif (buttonConnect) buttonConnect.onclick = onConnect;\nfunction sendHostInfo(connected) {\n    if (sandbox) sandbox.postMessage({\n        type: \"hostinfo\",\n        data: JSON.stringify({\n            connected\n        })\n    }, \"*\");\n    else console.warn(\"no sandbox\");\n}\n//interprets a message from the sandbox and calls a function depending on the type\nfunction receiveFromSandbox(event, publish = true) {\n    if (sandbox !== event.source) return;\n    if (window.send && publish) window.send(\"receivedFromSandbox\", event.data);\n    //we got a letter from sandbox\n    var msg = event.data;\n    logger(1, msg.toString());\n    switch(msg.type){\n        case \"raw\":\n            writeSerial(msg.data);\n            break;\n        case \"frame\":\n            sendArrayBuffer(prepareSerialFrame(msg.data));\n            if (!publish) sendToSandbox(msg.data);\n            break;\n        case \"resize\":\n            window.resizeTo(msg.data[0], msg.data[1]);\n            break;\n        default:\n            console.warn(\"unknown message type\");\n    }\n}\n//sends a message to the Sandbox\nfunction sendToSandbox(msg) {\n    // send a letter to sandbox\n    try {\n        if (sandbox) sandbox.postMessage({\n            type: \"frame\",\n            data: msg\n        }, \"*\");\n    } catch (e) {\n        console.warn(\"sendToSandbox failed:\", e.message);\n    }\n}\nfunction logger(lvl, msg) {\n    if (logging >= lvl) console.log(msg);\n}\n//\nfunction onReceiveCallback(info) {\n    if (!info) return;\n    if (window.station === true && window.send) // send the received data to the host\n    window.send(\"receive-buffer\", info);\n    var bytes = new Uint8Array(info);\n    logger(3, String.fromCharCode.apply(null, bytes));\n    for(var i in bytes){\n        var c = bytes[i];\n        logger(5, String.fromCharCode(c));\n        if (receiverstatus == frmstatus.in) {\n            if (c == SOF) {\n                //lost a frame but go on with a new one\n                receiverstatus = frmstatus.in;\n                stringReceived = \"\";\n            } else if (c == EOF) {\n                //frame complete send its contet to the sandbox\n                logger(1, \"rx Serial Frame: \" + stringReceived);\n                sendToSandbox(stringReceived);\n                stringReceived = \"\";\n                receiverstatus = frmstatus.no;\n            } else if (c == ESC) receiverstatus = frmstatus.esc;\n            else stringReceived += String.fromCharCode(c);\n        } else if (receiverstatus == frmstatus.esc) {\n            stringReceived += String.fromCharCode(ESC ^ ESCMASK);\n            receiverstatus = frmstatus.in;\n        } else if (receiverstatus == frmstatus.no) {\n            if (c == SOF) {\n                // start a new frame\n                receiverstatus = frmstatus.in;\n                stringReceived = \"\";\n            }\n        }\n    }\n}\n//send an ArrayBuffer to the serial connection\nfunction sendArrayBuffer(buf) {\n    if (window.station === false) return;\n    if (port) {\n        if (!writer) writer = port.writable.getWriter();\n        try {\n            // Write the data to the serial port.\n            writer.write(buf);\n        } catch (error) {\n            console.warn(\"Failed to write data to the serial port:\", error);\n        }\n    } else logger(2, \"not sent\");\n}\n// create a buffer that contains a frame that will be send to the serial connection\nfunction prepareSerialFrame(str) {\n    logger(1, \"tx Serial Frame: \" + str);\n    var buf = new ArrayBuffer(str.length * 2 + 2);\n    var bufView = new Uint8Array(buf);\n    var bufi = 0;\n    bufView[bufi] = SOF;\n    bufi++;\n    for(var i = 0; i < str.length; i++){\n        var c = str.charCodeAt(i);\n        if (c == SOF || c == EOF || c == ESC) {\n            bufView[bufi] = ESC;\n            bufView[bufi] = c ^ ESCMASK;\n            bufi += 2;\n        } else {\n            bufView[bufi] = c;\n            bufi++;\n        }\n    }\n    bufView[bufi] = EOF;\n    return buf;\n}\n// write a string to the serial connection\nfunction writeSerial(str) {\n    sendArrayBuffer(convertStringToArrayBuffer(str));\n}\n// Convert string to ArrayBuffer\nfunction convertStringToArrayBuffer(str) {\n    var buf = new ArrayBuffer(str.length);\n    var bufView = new Uint8Array(buf);\n    for(var i = 0; i < str.length; i++)bufView[i] = str.charCodeAt(i);\n    return buf;\n}\nasync function readFromPort() {\n    if (!port) return;\n    reader = port.readable.getReader();\n    try {\n        while(true){\n            const { value, done } = await reader.read();\n            if (done) break;\n            onReceiveCallback(value) // Reader has been released.\n            ;\n        }\n    } catch (error) {\n        console.warn(\"serial communication closed:\", error.message);\n    } finally{\n        reader.releaseLock();\n    }\n}\nfunction onConnect() {\n    buttonConnect.disabled = true;\n    const baudrate = window.document.getElementById(\"baudrate\");\n    const autoconnect = document.getElementById(\"autoconnect\");\n    if (window.station === false) {\n        window.send(\"connect\", null);\n        return;\n    }\n    if (buttonConnect.innerText === \"Connect\") connect().then((ok)=>{\n        buttonConnect.innerText = ok ? \"Disconnect\" : \"Connect\";\n        buttonConnect.disabled = false;\n        baudrate.disabled = ok;\n        autoconnect.disabled = ok;\n        window?.update();\n    });\n    else disconnect().then(()=>{\n        buttonConnect.innerText = \"Connect\";\n        buttonConnect.disabled = false;\n        baudrate.disabled = false;\n        autoconnect.disabled = false;\n        window?.update();\n        console.log(\"Disconnected\", window.state);\n    });\n}\nasync function connect() {\n    try {\n        const autoconnect = document.getElementById(\"autoconnect\");\n        console.log(\"port:\", autoconnect);\n        port = null;\n        if (autoconnect.checked) {\n            const ports = await communication.serial.getPorts();\n            if (ports.length > 0) port = ports[0];\n        }\n        if (!port) port = await communication.serial.requestPort();\n        if (port) {\n            const baudRate = parseInt(document.getElementById(\"baudrate\").value);\n            await port.open({\n                baudRate\n            });\n            console.log(\"Connected to:\", baudRate, port.getInfo());\n            readFromPort();\n            setTimeout(function() {\n                //initSandbox()\n                sendArrayBuffer(prepareSerialFrame(\"!!\"));\n                sendHostInfo(true);\n            }, 2000);\n            return true;\n        }\n    // Continue with opening the port, etc.\n    } catch (e) {\n        // Handle errors or rejections here\n        console.log(\"There was an error:\", e.message);\n        await disconnect();\n    }\n    return false;\n}\nasync function disconnect() {\n    if (!port) return;\n    sendHostInfo(false);\n    if (writer) {\n        await writer.releaseLock();\n        await port.writable.close();\n        writer = null;\n    }\n    if (reader) {\n        await reader.releaseLock();\n        await port.readable.cancel();\n        reader = null;\n    }\n    await port.close();\n    port = null;\n}\nfunction initSandbox() {\n    let localSandbox = document.getElementById(\"sandbox\");\n    if (localSandbox) {\n        localSandbox.src = \"./sandbox.html\";\n        sandbox = localSandbox.contentWindow;\n        if (window.station === false) {\n            window.send(\"reload\", null);\n            return;\n        }\n        if (port) {\n            sendArrayBuffer(prepareSerialFrame(\"!!\"));\n            sendHostInfo(true);\n        }\n    }\n}\n{\n    const buttonReload = document.getElementById(\"reload\");\n    if (buttonReload) buttonReload.onclick = initSandbox;\n    if (window.station === false) ;\n    else window.addEventListener(\"message\", receiveFromSandbox, false);\n    window.receiveFromSandBox = function(event, publish) {\n        receiveFromSandbox({\n            data: event,\n            source: sandbox\n        }, publish);\n    };\n    window.onReceiveCallback = onReceiveCallback;\n    window.sendArrayBuffer = sendArrayBuffer;\n}\n//# sourceMappingURL=index.a2301e6f.js.map\n","const communication = navigator as Navigator & {\n  serial?: any\n}\n\nvar port: any = null\nvar writer: any = null\nvar reader: any = null\n\nvar sandbox = (document.getElementById('sandbox') as HTMLIFrameElement)\n  ?.contentWindow\n\n// an object containing objects that can be distinguished from each other (is used like an enumeration in onReceiveCallback\nvar frmstatus = {\n  no: {},\n  in: {},\n  esc: {},\n}\n\nvar receiverstatus = frmstatus.no\nvar stringReceived = ''\n\n// teletype framing with escaping\nconst SOF = 0x01\nconst EOF = 0x04\nconst ESC = 0x10\nconst ESCMASK = 0x40\n\n//logger is used to debug the sending and receiving of messages logging contains the log,level, which determines how many messages are logged to the debug console\nvar logging = 0\n\nconst buttonConnect = document.getElementById('connect') as HTMLInputElement\nif (buttonConnect) {\n  buttonConnect.onclick = onConnect\n}\n\nfunction sendHostInfo(connected: boolean) {\n  if (sandbox) {\n    sandbox.postMessage(\n      { type: 'hostinfo', data: JSON.stringify({ connected }) },\n      '*'\n    )\n  } else {\n    console.warn('no sandbox')\n  }\n}\n\n//interprets a message from the sandbox and calls a function depending on the type\nfunction receiveFromSandbox(event: MessageEvent, publish = true) {\n  if (sandbox !== event.source) return\n\n  if (window.send && publish) {\n    window.send('receivedFromSandbox', event.data)\n  }\n\n  //we got a letter from sandbox\n  var msg = event.data\n  logger(1, msg.toString())\n\n  switch (msg.type) {\n    case 'raw':\n      writeSerial(msg.data)\n      break\n    case 'frame':\n      sendArrayBuffer(prepareSerialFrame(msg.data))\n\n      if (!publish) {\n        sendToSandbox(msg.data)\n      }\n      break\n    case 'resize':\n      window.resizeTo(msg.data[0], msg.data[1])\n      break\n    default:\n      console.warn('unknown message type')\n  }\n}\n\n//sends a message to the Sandbox\nfunction sendToSandbox(msg: string) {\n  // send a letter to sandbox\n  try {\n    if (sandbox) {\n      sandbox.postMessage({ type: 'frame', data: msg }, '*')\n    }\n  } catch (e) {\n    console.warn('sendToSandbox failed:', e.message)\n  }\n}\n\nfunction logger(lvl, msg) {\n  if (logging >= lvl) console.log(msg)\n}\n\n//\nfunction onReceiveCallback(info) {\n  if (!info) return\n\n  if (window.station === true && window.send) {\n    // send the received data to the host\n    window.send('receive-buffer', info)\n  }\n\n  var bytes = new Uint8Array(info)\n  logger(3, String.fromCharCode.apply(null, bytes))\n\n  for (var i in bytes) {\n    var c = bytes[i]\n    logger(5, String.fromCharCode(c))\n    if (receiverstatus == frmstatus.in) {\n      if (c == SOF) {\n        //lost a frame but go on with a new one\n        receiverstatus = frmstatus.in\n        stringReceived = ''\n      } else if (c == EOF) {\n        //frame complete send its contet to the sandbox\n        logger(1, 'rx Serial Frame: ' + stringReceived)\n        sendToSandbox(stringReceived)\n        stringReceived = ''\n        receiverstatus = frmstatus.no\n      } else if (c == ESC) {\n        receiverstatus = frmstatus.esc\n      } else {\n        stringReceived += String.fromCharCode(c)\n      }\n    } else if (receiverstatus == frmstatus.esc) {\n      stringReceived += String.fromCharCode(ESC ^ ESCMASK)\n      receiverstatus = frmstatus.in\n    } else if (receiverstatus == frmstatus.no) {\n      if (c == SOF) {\n        // start a new frame\n        receiverstatus = frmstatus.in\n        stringReceived = ''\n      }\n    }\n  }\n}\n\n//send an ArrayBuffer to the serial connection\nfunction sendArrayBuffer(buf: ArrayBuffer) {\n  if (window.station === false) {\n    return\n  }\n\n  if (port) {\n    if (!writer) writer = port.writable.getWriter()\n    try {\n      // Write the data to the serial port.\n      writer.write(buf)\n    } catch (error) {\n      console.warn('Failed to write data to the serial port:', error)\n    }\n  } else {\n    logger(2, 'not sent')\n  }\n}\n\n// create a buffer that contains a frame that will be send to the serial connection\nfunction prepareSerialFrame(str: string) {\n  logger(1, 'tx Serial Frame: ' + str)\n  var buf = new ArrayBuffer(str.length * 2 + 2)\n  var bufView = new Uint8Array(buf)\n  var bufi = 0\n  bufView[bufi] = SOF\n  bufi++\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i)\n    if (c == SOF || c == EOF || c == ESC) {\n      bufView[bufi] = ESC\n      bufView[bufi] = c ^ ESCMASK\n      bufi += 2\n    } else {\n      bufView[bufi] = c\n      bufi++\n    }\n  }\n  bufView[bufi] = EOF\n  return buf\n}\n\n// write a string to the serial connection\nfunction writeSerial(str: string) {\n  sendArrayBuffer(convertStringToArrayBuffer(str))\n}\n\n// Convert string to ArrayBuffer\nfunction convertStringToArrayBuffer(str: string) {\n  var buf = new ArrayBuffer(str.length)\n  var bufView = new Uint8Array(buf)\n  for (var i = 0; i < str.length; i++) {\n    bufView[i] = str.charCodeAt(i)\n  }\n  return buf\n}\n\nasync function readFromPort() {\n  if (!port) return\n\n  reader = port.readable.getReader()\n  try {\n    while (true) {\n      const { value, done } = await reader.read()\n      if (done) {\n        break\n      }\n\n      onReceiveCallback(value) // Reader has been released.\n    }\n  } catch (error) {\n    console.warn('serial communication closed:', error.message)\n  } finally {\n    reader.releaseLock()\n  }\n}\n\nfunction onConnect() {\n  buttonConnect.disabled = true\n  const baudrate = window.document.getElementById(\n    'baudrate'\n  ) as HTMLInputElement\n  const autoconnect = document.getElementById('autoconnect') as HTMLInputElement\n\n  if (window.station === false) {\n    window.send('connect', null)\n    return\n  }\n\n  if (buttonConnect.innerText === 'Connect') {\n    connect().then((ok: boolean) => {\n      buttonConnect.innerText = ok ? 'Disconnect' : 'Connect'\n      buttonConnect.disabled = false\n\n      baudrate.disabled = ok\n      autoconnect.disabled = ok\n\n      window?.update()\n    })\n  } else {\n    disconnect().then(() => {\n      buttonConnect.innerText = 'Connect'\n      buttonConnect.disabled = false\n\n      baudrate.disabled = false\n      autoconnect.disabled = false\n\n      window?.update()\n      console.log('Disconnected', window.state)\n    })\n  }\n}\n\nasync function connect() {\n  try {\n    const autoconnect = document.getElementById(\n      'autoconnect'\n    ) as HTMLInputElement\n    console.log('port:', autoconnect)\n\n    port = null\n    if (autoconnect.checked) {\n      const ports = await communication.serial.getPorts()\n      if (ports.length > 0) {\n        port = ports[0]\n      }\n    }\n\n    if (!port) {\n      port = await communication.serial.requestPort()\n    }\n\n    if (port) {\n      const baudRate = parseInt(\n        (document.getElementById('baudrate') as HTMLInputElement).value\n      )\n      await port.open({ baudRate })\n\n      console.log('Connected to:', baudRate, port.getInfo())\n\n      readFromPort()\n\n      setTimeout(function () {\n        //initSandbox()\n        sendArrayBuffer(prepareSerialFrame('!!'))\n        sendHostInfo(true)\n      }, 2000)\n\n      return true\n    }\n    // Continue with opening the port, etc.\n  } catch (e) {\n    // Handle errors or rejections here\n    console.log('There was an error:', e.message)\n    await disconnect()\n  }\n  return false\n}\n\nasync function disconnect() {\n  if (!port) return\n\n  sendHostInfo(false)\n\n  if (writer) {\n    await writer.releaseLock()\n    await port.writable.close()\n    writer = null\n  }\n\n  if (reader) {\n    await reader.releaseLock()\n    await port.readable.cancel()\n    reader = null\n  }\n\n  await port.close()\n  port = null\n}\n\nfunction initSandbox() {\n  let localSandbox = document.getElementById('sandbox') as HTMLIFrameElement\n\n  if (localSandbox) {\n    localSandbox.src = './sandbox.html'\n    sandbox = (localSandbox as HTMLIFrameElement).contentWindow\n\n    if (window.station === false) {\n      window.send('reload', null)\n      return\n    }\n\n    if (port) {\n      sendArrayBuffer(prepareSerialFrame('!!'))\n      sendHostInfo(true)\n    }\n  }\n}\n\n{\n  const buttonReload = document.getElementById('reload') as HTMLInputElement\n  if (buttonReload) {\n    buttonReload.onclick = initSandbox\n  }\n\n  if (window.station === false) {\n  } else {\n    window.addEventListener('message', receiveFromSandbox, false)\n  }\n\n  window.receiveFromSandBox = function (event, publish) {\n    receiveFromSandbox({ data: event, source: sandbox }, publish)\n  }\n  window.onReceiveCallback = onReceiveCallback\n  window.sendArrayBuffer = sendArrayBuffer\n}\n"],"names":["communication","navigator","port","writer","reader","sandbox","document","getElementById","contentWindow","frmstatus","no","in","esc","receiverstatus","stringReceived","buttonConnect","sendHostInfo","connected","postMessage","type","data","JSON","stringify","console","warn","receiveFromSandbox","event","publish","source","window","send","msg","logger","toString","sendArrayBuffer","convertStringToArrayBuffer","str","buf","ArrayBuffer","length","bufView","Uint8Array","i","charCodeAt","prepareSerialFrame","sendToSandbox","resizeTo","e","message","lvl","log","onReceiveCallback","info","station","bytes","String","fromCharCode","apply","c","writable","getWriter","write","error","bufi","readFromPort","readable","getReader","value","done","read","releaseLock","connect","autoconnect","checked","ports","serial","getPorts","requestPort","baudRate","parseInt","open","getInfo","setTimeout","disconnect","close","cancel","onclick","disabled","baudrate","innerText","then","ok","update","state","buttonReload","localSandbox","src","addEventListener","receiveFromSandBox"],"version":3,"file":"index.a2301e6f.js.map"}